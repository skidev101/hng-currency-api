model Country {
  id                Int      @id @default(autoincrement())
  name              String   @unique
  capital           String?
  region            String?
  population        BigInt
  currency_code     String?
  exchange_rate     Float?
  estimated_gdp     Float?
  flag_url          String?
  last_refreshed_at DateTime @default(now())
}

model Metadata {
  id         Int      @id @default(autoincrement())
  key        String   @unique
  value      String
  updated_at DateTime @updatedAt
}


import axios, { AxiosError } from "axios";
import { PrismaClient } from "@prisma/client";
import pLimit from "p-limit";
import { generateSummaryImg } from "../utils/generateSummaryImg"; // adjust path
import { calculateEstimatedGdp } from "../utils/calculateEstimatedGdp";

const prisma = new PrismaClient();

export const refreshCountries = async () => {
  const timestamp = new Date();

  try {
    // 1️⃣ Fetch external data in parallel
    const [countriesRes, exchangeRes] = await Promise.all([
      axios.get(process.env.COUNTRIES_API_URL!),
      axios.get(process.env.EXCHANGE_RATES_API_URL!),
    ]);

    const countries = countriesRes.data;
    const exchangeRates = exchangeRes.data?.rates;

    if (!Array.isArray(countries) || !exchangeRates) {
      throw new Error("Invalid data structure from APIs");
    }

    // 2️⃣ Process countries concurrently but safely (limit concurrency)
    const limit = pLimit(10); // adjust concurrency as needed
    let processedCount = 0;

    const upserts = countries.map((countryData) =>
      limit(async () => {
        try {
          const currencyCode =
            countryData.currencies?.[0]?.code ?? null;

          // handle missing or unknown currencies gracefully
          const exchangeRate = currencyCode
            ? exchangeRates[currencyCode] ?? null
            : null;

          // GDP: population × random(1000–2000) ÷ exchange_rate
          let estimatedGdp: number | null = null;

          if (exchangeRate && exchangeRate > 0) {
            const randomMultiplier =
              Math.floor(Math.random() * (2000 - 1000 + 1)) + 1000;
            estimatedGdp = Number(
              (BigInt(countryData.population) * BigInt(randomMultiplier)) /
                BigInt(Math.round(exchangeRate))
            );
          } else {
            estimatedGdp = 0;
          }

          // 3️⃣ Upsert country
          await prisma.country.upsert({
            where: {
              name: countryData.name, // case-sensitive match; adjust if needed
            },
            update: {
              capital: countryData.capital ?? null,
              region: countryData.region ?? null,
              population: BigInt(countryData.population),
              currency_code: currencyCode,
              exchange_rate: exchangeRate,
              estimated_gdp: estimatedGdp,
              flag_url: countryData.flag ?? null,
              last_refreshed_at: timestamp,
            },
            create: {
              name: countryData.name,
              capital: countryData.capital ?? null,
              region: countryData.region ?? null,
              population: BigInt(countryData.population),
              currency_code: currencyCode,
              exchange_rate: exchangeRate,
              estimated_gdp: estimatedGdp,
              flag_url: countryData.flag ?? null,
              last_refreshed_at: timestamp,
            },
          });

          processedCount++;
        } catch (error) {
          console.error(
            `Failed to process ${countryData.name}:`,
            (error as Error).message
          );
        }
      })
    );

    await Promise.all(upserts);

    // 4️⃣ Update metadata
    await prisma.metadata.upsert({
      where: { key: "updated_at" },
      update: { value: timestamp.toISOString() },
      create: { key: "updated_at", value: timestamp.toISOString() },
    });

    // 5️⃣ Generate summary image
    await generateSummaryImg();

    return {
      message: "Countries refreshed successfully",
      countries_processed: processedCount,
      timestamp: timestamp.toISOString(),
    };
  } catch (error) {
    const axiosError = error as AxiosError;
    console.error("Refresh failed:", axiosError.message);

    throw {
      status: 503,
      error: "External data source unavailable",
      details:
        axiosError.code === "ECONNABORTED"
          ? "External API timeout"
          : axiosError.message,
    };
  }
};
